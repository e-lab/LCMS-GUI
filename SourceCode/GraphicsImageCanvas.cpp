/**
 * @file
 * The Graphing System.
 *
 * This file contains the classes which, taken together, make up the
 * classes needed to display the data generated by the hardware.
 */
#include "GraphicsImageCanvas.h"

/*
 *  GraphicsImageCanvas. This will have the image painted on it.wxSize(width, height)
 */
GraphicsImageCanvas::GraphicsImageCanvas (wxWindow* owner) : wxPanel (owner)
{
	width = 5;
	height = 5;
	length = (width * height);
	imageData = new float[length];

	image = new wxBitmap (width, height, 32);
	fullscreen = (wxFrame*) NULL;

	for (int i = 0; i < length; i++) {
		imageData[i] = 0;
	}

	SetBackgroundStyle (wxBG_STYLE_CUSTOM);

	Connect (wxEVT_PAINT, wxPaintEventHandler (GraphicsImageCanvas::OnPaint));
	Connect (wxEVT_LEFT_DCLICK, wxMouseEventHandler (GraphicsImageCanvas::OnDoubleClick));
}

GraphicsImageCanvas::~GraphicsImageCanvas()
{
	delete		image;
	image =	(wxBitmap*) NULL;

	delete[]	imageData;
	imageData =	NULL;
}

void GraphicsImageCanvas::SetData (int width_t, int height_t, float* imageData_t, int length_t)
{
	width = width_t;
	height = height_t;

	length = length_t;

	delete[] imageData;
	imageData = imageData_t;

	delete image;
	image = new wxBitmap (width, height, 32);
}

float* GraphicsImageCanvas::GetImageData (int& length_t)
{
	length_t = length;
	return imageData;
}

void GraphicsImageCanvas::OnPaint (wxPaintEvent& event)
{
	wxAlphaPixelData data (*image);
	if (!data) {
		wxLogError (wxT ("Failed to gain access to raw bitmap data"));
		event.Skip();
		return;
	}

	wxAlphaPixelData::Iterator p (data);

	p.Offset (data, 0, 0); // no offset

	// Finding the maximum
	int max = 0;
	for (int ii = 0; ii < length; ii++) {
		if (max < imageData[ii]) {
			max = imageData[ii];
		}
	}

	for (int y = 0; y < height; ++y) {
		wxAlphaPixelData::Iterator rowStart = p;

		//for (int x = 0; x < width; ++x, ++p) {
		for (int x = (width - 1); x >= 0; --x, ++p) {
			p.Red() = ( (this->imageData[ (y * width) + x]) /max) * 255;
			p.Green() = ( (this->imageData[ (y * width) + x]) /max) * 255;
			p.Blue() = ( (this->imageData[ (y * width) + x]) /max) * 255;
		}
		p = rowStart;
		p.OffsetY (data, 1);
	}

	wxBufferedPaintDC dci (this);

	// Find the image scale factor and center the image.
	double scaleW = ( (double) image->GetWidth() / (double) (GetClientSize()).GetWidth());
	double scaleH = ( (double) image->GetHeight() / (double) (GetClientSize()).GetHeight());
	double scaleImage = 1;

	if (scaleW > scaleH) {
		scaleImage = scaleW;
	} else {
		scaleImage = scaleH;
	}

	// The commented out code worked in xp but not osx
	//SetSize(width/scaleImage, height/scaleImage);
	//dci.DrawBitmap (*this->image, 0, 0, true);
	//dci.SetUserScale (scaleImage, scaleImage);
	//if (NULL != fullscreen){
	//	CentreOnParent();
	//}

	wxImage displayImage = image->ConvertToImage();

	displayImage = displayImage.Scale (displayImage.GetWidth() /scaleImage, displayImage.GetHeight() /scaleImage);

	int cw = (GetClientSize()).GetWidth();
	int ch = (GetClientSize()).GetHeight();
	int pw = ( (cw - displayImage.GetWidth()) /2);
	int ph = ( (ch - displayImage.GetHeight()) /2);
	displayImage = displayImage.Size (wxSize (cw, ch), wxPoint (pw, ph), 0, 0, 0);

	wxBitmap tmpBitmap = wxBitmap (displayImage);
	dci.DrawBitmap (tmpBitmap, 0, 0, true);
}


void GraphicsImageCanvas::OnDoubleClick (wxMouseEvent& event)
{
	if (NULL == fullscreen) {
		fullscreen = new wxFrame (GetParent(), wxID_ANY, wxT ("Fullscreen"));
		fullscreen->Show (TRUE);
		fullscreen->ShowFullScreen (true, wxFULLSCREEN_ALL);
		fullscreen->SetBackgroundColour (wxT ("black"));

		Reparent (fullscreen);
		SetSize (wxGetDisplaySize());
		CentreOnParent();
		return;
	} else {
		Reparent (fullscreen->GetParent());
		(GetParent())->Layout();

		fullscreen->Close (TRUE);
		delete fullscreen;
		fullscreen = (wxFrame*) NULL;
		return;

	}

}

